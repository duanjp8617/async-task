ThreadId(1): [Task 1] [executor1::spawn] -> creating a new task
ThreadId(1): [Task 1] [schedule closure] -> schedule closure is called
ThreadId(11): run task 1
ThreadId(1): [Task 1] [Self-defined JoinHandle::poll] -> polling Self-defined JoinHandle
ThreadId(11): [Task 1] [RawTask::run] [Hdr: Schedule:t, Run:f, Completed:f, Closed:f, Handle:t, Awaiter:f, Registering:f, Notifying:f, Rc:1] -> before unmarking scheduling and marking running
ThreadId(1): [Task 1] [JoinHandle::poll] [Hdr: Schedule:t, Run:f, Completed:f, Closed:f, Handle:t, Awaiter:f, Registering:f, Notifying:f, Rc:1] -> load state for polling
ThreadId(1): [Task 1] [JoinHandle::Poll] -> task is not complted, register a waker
ThreadId(11): [Task 1] [RawTask::run] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:f, Registering:f, Notifying:f, Rc:1] -> after unmarking scheduling and marking running
ThreadId(1): [Task 1] [Header::register] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:f, Registering:f, Notifying:f, Rc:1] -> load state with fetch_or(0)?
ThreadId(11): [Task 2] [executor1::spawn] -> creating a new task
ThreadId(1): [Task 1] [Header::register] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:f, Registering:t, Notifying:f, Rc:1] -> turn register on, register: t, notifying: f
ThreadId(11): [Task 2] [schedule closure] -> schedule closure is called
ThreadId(1): [Task 1] [Header::register] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1] -> finish registering
ThreadId(1): [Task 1] [JoinHandle::poll] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1] -> finish register an awaiter, sync state
ThreadId(12): run task 2
ThreadId(1): [Task 1] [JoinHandle::poll] -> task is not completed, return pending
ThreadId(11): [Task 2] [Self-defined JoinHandle::poll] -> polling Self-defined JoinHandle
ThreadId(12): [Task 2] [RawTask::run] [Hdr: Schedule:t, Run:f, Completed:f, Closed:f, Handle:t, Awaiter:f, Registering:f, Notifying:f, Rc:1] -> before unmarking scheduling and marking running
ThreadId(11): [Task 2] [JoinHandle::poll] [Hdr: Schedule:t, Run:f, Completed:f, Closed:f, Handle:t, Awaiter:f, Registering:f, Notifying:f, Rc:1] -> load state for polling
ThreadId(11): [Task 2] [JoinHandle::Poll] -> task is not complted, register a waker
ThreadId(11): [Task 2] [Header::register] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:f, Registering:f, Notifying:f, Rc:1] -> load state with fetch_or(0)?
ThreadId(11): [Task 2] [Header::register] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:f, Registering:t, Notifying:f, Rc:1] -> turn register on, register: t, notifying: f
ThreadId(11): [Task 1] [RawTask::clone_waker] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:2] -> increasing task reference
ThreadId(11): [Task 2] [Header::register] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1] -> finish registering
ThreadId(11): [Task 2] [JoinHandle::poll] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1] -> finish register an awaiter, sync state
ThreadId(11): [Task 2] [JoinHandle::poll] -> task is not completed, return pending
ThreadId(11): [Task 1] [RawTask::run] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:2] -> after polling future
ThreadId(12): [Task 2] [RawTask::run] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:f, Registering:f, Notifying:f, Rc:1] -> after unmarking scheduling and marking running
ThreadId(12): [async closure] -> run async_closure
ThreadId(12): [Task 2] [RawTask::clone_waker] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:2] -> increasing task reference
ThreadId(12): [Task 2] [RawTask::run] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:2] -> after polling future
ThreadId(2): [Thread Closure] -> send to the sender channel
ThreadId(2): [Task 2] [RawTask::wake] "[Hdr: Schedule:f, Run:f, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1]" -> wake is called
ThreadId(2): [Task 2] [schedule closure] -> schedule closure is called
ThreadId(5): run task 2
ThreadId(5): [Task 2] [RawTask::run] [Hdr: Schedule:t, Run:f, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1] -> before unmarking scheduling and marking running
ThreadId(5): [Task 2] [RawTask::run] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1] -> after unmarking scheduling and marking running
ThreadId(5): [Task 2] [RawTask::run] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1] -> after polling future
ThreadId(5): [Task 2] [RawTask::run] "[Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1]" -> notify awaiter
ThreadId(5): [Task 1] [RawTask::wake] "[Hdr: Schedule:f, Run:f, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1]" -> wake is called
ThreadId(5): [Task 1] [schedule closure] -> schedule closure is called
ThreadId(5): run task 1
ThreadId(5): [Task 1] [RawTask::run] [Hdr: Schedule:t, Run:f, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1] -> before unmarking scheduling and marking running
ThreadId(5): [Task 1] [RawTask::run] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1] -> after unmarking scheduling and marking running
ThreadId(5): [Task 2] [Self-defined JoinHandle::poll] -> polling Self-defined JoinHandle
ThreadId(5): [Task 2] [JoinHandle::poll] [Hdr: Schedule:f, Run:f, Completed:t, Closed:f, Handle:t, Awaiter:f, Registering:f, Notifying:f, Rc:0] -> load state for polling
ThreadId(5): [Task 2] [JoinHandle::poll] [Hdr: Schedule:f, Run:f, Completed:t, Closed:t, Handle:t, Awaiter:f, Registering:f, Notifying:f, Rc:0] -> task is closed in JoinHandle
ThreadId(5): [Task 2] [JoinHandle::poll] -> task finishes, return output
ThreadId(5): [Task 1] [RawTask::run] [Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1] -> after polling future
ThreadId(5): [Task 1] [RawTask::run] "[Hdr: Schedule:f, Run:t, Completed:f, Closed:f, Handle:t, Awaiter:t, Registering:f, Notifying:f, Rc:1]" -> notify awaiter
ThreadId(5): [Waker] -> waker is called to unpark
ThreadId(1): [Task 1] [Self-defined JoinHandle::poll] -> polling Self-defined JoinHandle
ThreadId(1): [Task 1] [JoinHandle::poll] [Hdr: Schedule:f, Run:f, Completed:t, Closed:f, Handle:t, Awaiter:f, Registering:f, Notifying:f, Rc:0] -> load state for polling
ThreadId(1): [Task 1] [JoinHandle::poll] [Hdr: Schedule:f, Run:f, Completed:t, Closed:t, Handle:t, Awaiter:f, Registering:f, Notifying:f, Rc:0] -> task is closed in JoinHandle
ThreadId(1): [Task 1] [JoinHandle::poll] -> task finishes, return output
1
